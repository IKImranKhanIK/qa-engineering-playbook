# Test Data Management

## Overview

Test data management involves creating, maintaining, and controlling data used for testing. Good test data enables realistic testing while bad test data causes flaky tests, false positives, and missed bugs.

## Why Test Data Management Matters

### The Problem

**Scenario: Payment Testing**

```javascript
// Test depends on specific credit card in database
it('should process payment', async () => {
  const card = await db.getCreditCard('card_12345'); // Hard-coded ID
  const result = await processPayment(card, 50.00);
  expect(result.status).toBe('success');
});
```

**Issues:**
- âŒ Test fails if `card_12345` deleted
- âŒ Test can't run in parallel (other tests use same card)
- âŒ Test fails in different environments (staging vs prod)
- âŒ Test requires manual database setup

### The Solution

```javascript
// Test creates its own data
it('should process payment', async () => {
  const card = await createTestCreditCard({ balance: 1000 }); // Fresh data
  const result = await processPayment(card, 50.00);
  expect(result.status).toBe('success');
  await cleanup(card); // Clean up after test
});
```

**Benefits:**
- âœ… Test is self-contained
- âœ… Can run in parallel
- âœ… Works in any environment
- âœ… No manual setup required

---

## Types of Test Data

### 1. Static Test Data

**Definition:** Pre-created, fixed data in database/files

**When to Use:**
- Reference data (countries, currencies, product categories)
- Configuration data
- Lookup tables

**Example:**

```sql
-- Static reference data
INSERT INTO countries (code, name) VALUES
  ('US', 'United States'),
  ('UK', 'United Kingdom'),
  ('CA', 'Canada');

INSERT INTO currencies (code, symbol) VALUES
  ('USD', '$'),
  ('GBP', 'Â£'),
  ('EUR', 'â‚¬');
```

**Pros:**
- Fast (data already exists)
- Consistent across tests
- Realistic (production-like)

**Cons:**
- Can become stale
- Harder to isolate tests
- Requires database maintenance

### 2. Dynamic Test Data

**Definition:** Generated during test execution

**When to Use:**
- User accounts
- Orders
- Transactions
- Test-specific scenarios

**Example:**

```javascript
// Generate unique test data
function createTestUser() {
  return {
    email: `test-${Date.now()}@example.com`,
    name: `Test User ${Math.random().toString(36).substr(2, 9)}`,
    password: 'TestPassword123!',
    createdAt: new Date()
  };
}

// Use in test
it('should create new user', async () => {
  const testUser = createTestUser(); // Fresh data every time
  const response = await api.post('/users', testUser);
  expect(response.status).toBe(201);
});
```

**Pros:**
- No conflicts between tests
- Tests can run in parallel
- Always fresh data

**Cons:**
- Slower (data generation overhead)
- May not reflect production reality
- Cleanup required

### 3. Synthetic Test Data

**Definition:** Fake but realistic data generated by libraries

**When to Use:**
- Performance testing (large volumes)
- Edge case testing
- Anonymized production-like data

**Example with Faker.js:**

```javascript
const { faker } = require('@faker-js/faker');

function generateTestUser() {
  return {
    firstName: faker.person.firstName(),
    lastName: faker.person.lastName(),
    email: faker.internet.email(),
    phone: faker.phone.number(),
    address: {
      street: faker.location.streetAddress(),
      city: faker.location.city(),
      state: faker.location.state(),
      zip: faker.location.zipCode(),
      country: faker.location.country()
    },
    creditCard: {
      number: faker.finance.creditCardNumber(),
      cvv: faker.finance.creditCardCVV(),
      expiry: `${faker.date.future().getMonth() + 1}/${faker.date.future().getFullYear()}`
    }
  };
}

// Generate bulk data
function generateTestOrders(count) {
  return Array.from({ length: count }, () => ({
    orderId: faker.string.uuid(),
    userId: faker.number.int({ min: 1000, max: 9999 }),
    total: faker.finance.amount({ min: 10, max: 500, dec: 2 }),
    status: faker.helpers.arrayElement(['pending', 'paid', 'shipped', 'delivered']),
    createdAt: faker.date.past()
  }));
}

// Performance test with 10,000 orders
it('should handle bulk order import', async () => {
  const orders = generateTestOrders(10000);
  const result = await bulkImportOrders(orders);
  expect(result.imported).toBe(10000);
});
```

**Popular Faker Libraries:**
- **JavaScript:** @faker-js/faker
- **Python:** Faker
- **Java:** JavaFaker
- **Ruby:** Faker
- **.NET:** Bogus

### 4. Production Data (Sanitized)

**Definition:** Real production data with sensitive information removed

**When to Use:**
- Reproducing production bugs
- Performance testing with realistic data
- Edge cases found in production

**Example: Data Sanitization**

```javascript
// Sanitize production data for testing
function sanitizeUserData(productionUser) {
  return {
    id: productionUser.id,
    // Mask email
    email: `user${productionUser.id}@test.example.com`,
    // Fake name
    name: `Test User ${productionUser.id}`,
    // Remove sensitive data
    ssn: 'XXX-XX-XXXX',
    creditCard: '**** **** **** 1234',
    // Keep non-sensitive data
    accountType: productionUser.accountType,
    registrationDate: productionUser.registrationDate,
    preferences: productionUser.preferences
  };
}

// Export sanitized data
async function exportSanitizedData() {
  const productionUsers = await db.query('SELECT * FROM users LIMIT 1000');
  const sanitizedUsers = productionUsers.map(sanitizeUserData);
  await fs.writeFile('test-data/users.json', JSON.stringify(sanitizedUsers));
}
```

**Legal/Compliance:**
- âš ï¸ **GDPR (Europe):** PII must be anonymized
- âš ï¸ **HIPAA (US Healthcare):** PHI must be de-identified
- âš ï¸ **PCI-DSS (Payments):** Credit card data must be masked
- âš ï¸ **CCPA (California):** Personal data protections

---

## Test Data Strategies

### Strategy 1: Data Builder Pattern

**Problem:** Creating complex test objects is repetitive

**Solution:** Use builder pattern

```javascript
// user-builder.js
class UserBuilder {
  constructor() {
    this.user = {
      email: `test-${Date.now()}@example.com`,
      name: 'Test User',
      password: 'Password123!',
      role: 'user',
      active: true,
      verified: false
    };
  }

  withEmail(email) {
    this.user.email = email;
    return this;
  }

  withRole(role) {
    this.user.role = role;
    return this;
  }

  asAdmin() {
    this.user.role = 'admin';
    return this;
  }

  verified() {
    this.user.verified = true;
    return this;
  }

  inactive() {
    this.user.active = false;
    return this;
  }

  async create() {
    const response = await api.post('/users', this.user);
    return response.data;
  }
}

// Usage in tests
it('should allow admin to delete users', async () => {
  const admin = await new UserBuilder()
    .withEmail('admin@test.com')
    .asAdmin()
    .verified()
    .create();

  const response = await api.delete('/users/123', { authUser: admin });
  expect(response.status).toBe(200);
});

it('should reject unverified user login', async () => {
  const user = await new UserBuilder()
    .withEmail('unverified@test.com')
    .create(); // Not verified by default

  const response = await api.post('/login', {
    email: user.email,
    password: 'Password123!'
  });
  expect(response.status).toBe(403);
  expect(response.data.error).toBe('Email not verified');
});
```

### Strategy 2: Test Fixtures

**Problem:** Tests need consistent baseline data

**Solution:** Use fixtures to set up known state

```javascript
// fixtures/users.js
module.exports = {
  admin: {
    email: 'admin@test.com',
    name: 'Admin User',
    role: 'admin',
    password: 'AdminPass123!'
  },
  standardUser: {
    email: 'user@test.com',
    name: 'Standard User',
    role: 'user',
    password: 'UserPass123!'
  },
  premiumUser: {
    email: 'premium@test.com',
    name: 'Premium User',
    role: 'user',
    subscriptionTier: 'premium',
    password: 'PremiumPass123!'
  }
};

// fixtures/products.js
module.exports = {
  laptop: {
    name: 'Test Laptop',
    price: 999.99,
    category: 'electronics',
    stock: 100
  },
  book: {
    name: 'Test Book',
    price: 29.99,
    category: 'books',
    stock: 50
  }
};

// Use in tests
const fixtures = require('./fixtures/users');

beforeEach(async () => {
  // Load fixtures before each test
  await db.loadFixtures(fixtures);
});

it('should allow admin to view all users', async () => {
  const admin = fixtures.admin;
  const response = await api.get('/admin/users', { authUser: admin });
  expect(response.data.users.length).toBeGreaterThan(0);
});
```

### Strategy 3: Database Seeding

**Problem:** Tests need realistic database state

**Solution:** Seed database with test data

```javascript
// seeds/test-data.js
exports.seed = async function(knex) {
  // Clear existing data
  await knex('orders').del();
  await knex('users').del();

  // Seed users
  const users = await knex('users').insert([
    { id: 1, email: 'user1@test.com', name: 'User One' },
    { id: 2, email: 'user2@test.com', name: 'User Two' },
    { id: 3, email: 'user3@test.com', name: 'User Three' }
  ]).returning('*');

  // Seed orders
  await knex('orders').insert([
    { userId: 1, total: 50.00, status: 'pending' },
    { userId: 1, total: 75.00, status: 'paid' },
    { userId: 2, total: 100.00, status: 'shipped' }
  ]);
};

// Run seeds before tests
beforeAll(async () => {
  await db.migrate.latest();
  await db.seed.run();
});

// Tests now have consistent data
it('should get user orders', async () => {
  const response = await api.get('/users/1/orders');
  expect(response.data.orders.length).toBe(2);
});
```

### Strategy 4: Test Data Isolation

**Problem:** Tests interfere with each other's data

**Solution:** Use transactions or separate databases

**Option A: Transactions (Fast)**

```javascript
// Wrap each test in transaction, rollback after
beforeEach(async () => {
  await db.beginTransaction();
});

afterEach(async () => {
  await db.rollback(); // Undo all changes
});

it('should create user', async () => {
  await db.insert('users').values({ email: 'test@test.com' });
  const user = await db.select('*').from('users').where({ email: 'test@test.com' });
  expect(user).toBeDefined();
  // Rollback happens automatically, user not persisted
});
```

**Option B: Separate Test Databases**

```javascript
// Each test gets its own database
async function createTestDatabase() {
  const dbName = `test_${Date.now()}`;
  await adminDb.query(`CREATE DATABASE ${dbName}`);
  return connectToDatabase(dbName);
}

beforeEach(async () => {
  testDb = await createTestDatabase();
  await testDb.migrate.latest();
});

afterEach(async () => {
  await testDb.destroy();
  await adminDb.query(`DROP DATABASE ${testDb.config.database}`);
});
```

**Option C: Testcontainers (Best for CI/CD)**

```javascript
const { GenericContainer } = require('testcontainers');

describe('Database Tests', () => {
  let postgresContainer;
  let db;

  beforeAll(async () => {
    // Start fresh PostgreSQL container for this test suite
    postgresContainer = await new GenericContainer('postgres:14')
      .withExposedPorts(5432)
      .withEnv('POSTGRES_PASSWORD', 'test')
      .withEnv('POSTGRES_DB', 'testdb')
      .start();

    const port = postgresContainer.getMappedPort(5432);
    db = await connectToDatabase({
      host: 'localhost',
      port: port,
      database: 'testdb',
      user: 'postgres',
      password: 'test'
    });

    await db.migrate.latest();
  });

  afterAll(async () => {
    await db.destroy();
    await postgresContainer.stop();
  });

  // Each test suite has isolated database
  it('should create user', async () => {
    await db.insert({ email: 'test@test.com' }).into('users');
    const users = await db.select('*').from('users');
    expect(users.length).toBe(1);
  });
});
```

### Strategy 5: Data Versioning

**Problem:** Test data changes over time, breaks tests

**Solution:** Version test data with migrations

```javascript
// test-data-migrations/001_initial_users.js
exports.up = async function(db) {
  await db.insert({
    email: 'test-user-v1@test.com',
    name: 'Test User V1',
    version: 1
  }).into('users');
};

exports.down = async function(db) {
  await db('users').where({ version: 1 }).del();
};

// test-data-migrations/002_add_admin_user.js
exports.up = async function(db) {
  await db.insert({
    email: 'admin@test.com',
    name: 'Admin User',
    role: 'admin',
    version: 2
  }).into('users');
};

exports.down = async function(db) {
  await db('users').where({ version: 2 }).del();
};

// Run migrations before tests
beforeAll(async () => {
  await testDataMigrator.latest();
});
```

---

## Test Data Best Practices

### 1. Make Tests Data-Independent

**Bad (Depends on specific data):**

```javascript
it('should get user by email', async () => {
  // Assumes user exists in database
  const response = await api.get('/users?email=john@example.com');
  expect(response.data.name).toBe('John Doe');
});
```

**Good (Creates own data):**

```javascript
it('should get user by email', async () => {
  // Create test user
  const testUser = await createUser({
    email: 'test@test.com',
    name: 'Test User'
  });

  const response = await api.get(`/users?email=${testUser.email}`);
  expect(response.data.name).toBe(testUser.name);

  // Cleanup
  await deleteUser(testUser.id);
});
```

### 2. Use Realistic Data

**Bad (Unrealistic data misses bugs):**

```javascript
const user = {
  name: 'a',
  email: 'a@a.a',
  phone: '1',
  address: 'x'
};
```

**Good (Realistic data finds real issues):**

```javascript
const user = {
  name: 'MarÃ­a JosÃ© GarcÃ­a-LÃ³pez',  // Accents, hyphens, spaces
  email: 'maria.jose+test@company.co.uk',  // Plus addressing, .co.uk
  phone: '+44 20 7946 0958',  // International format
  address: '123 O\'Brien St, Apt #4B'  // Apostrophe, hashtag
};
```

### 3. Test Edge Cases

```javascript
describe('Name validation', () => {
  const edgeCases = [
    { name: '', expected: 'error' },  // Empty
    { name: 'A', expected: 'success' },  // Single char
    { name: 'X'.repeat(256), expected: 'error' },  // Too long
    { name: 'FranÃ§ois', expected: 'success' },  // Accent
    { name: 'O\'Brien', expected: 'success' },  // Apostrophe
    { name: 'Mary-Jane', expected: 'success' },  // Hyphen
    { name: 'Jose GarcÃ­a LÃ³pez', expected: 'success' },  // Multiple spaces
    { name: 'ææ˜', expected: 'success' },  // Chinese
    { name: 'Ù…Ø­Ù…Ø¯', expected: 'success' },  // Arabic
    { name: 'ğŸ‰ Party', expected: 'error' },  // Emoji
    { name: '<script>alert("XSS")</script>', expected: 'error' },  // XSS
    { name: 'Robert\'); DROP TABLE users;--', expected: 'error' }  // SQL injection
  ];

  edgeCases.forEach(({ name, expected }) => {
    it(`should ${expected === 'success' ? 'accept' : 'reject'} name: "${name}"`, async () => {
      const result = await validateName(name);
      expect(result.status).toBe(expected);
    });
  });
});
```

### 4. Clean Up Test Data

**Always clean up after tests:**

```javascript
// Option 1: Cleanup in afterEach
afterEach(async () => {
  await db.cleanupTestData();
});

// Option 2: Track created data and delete
class TestDataTracker {
  constructor() {
    this.createdUsers = [];
    this.createdOrders = [];
  }

  async createUser(data) {
    const user = await api.post('/users', data);
    this.createdUsers.push(user.id);
    return user;
  }

  async createOrder(data) {
    const order = await api.post('/orders', data);
    this.createdOrders.push(order.id);
    return order;
  }

  async cleanup() {
    for (const orderId of this.createdOrders) {
      await api.delete(`/orders/${orderId}`);
    }
    for (const userId of this.createdUsers) {
      await api.delete(`/users/${userId}`);
    }
    this.createdUsers = [];
    this.createdOrders = [];
  }
}

// Use in tests
let tracker;

beforeEach(() => {
  tracker = new TestDataTracker();
});

afterEach(async () => {
  await tracker.cleanup();
});

it('should create order', async () => {
  const user = await tracker.createUser({ email: 'test@test.com' });
  const order = await tracker.createOrder({ userId: user.id, total: 50 });
  expect(order.id).toBeDefined();
  // Cleanup happens automatically
});
```

### 5. Use Data Factories

**Centralize test data creation:**

```javascript
// factories/user-factory.js
class UserFactory {
  static create(overrides = {}) {
    return {
      email: `test-${Date.now()}@test.com`,
      name: 'Test User',
      password: 'TestPass123!',
      role: 'user',
      active: true,
      ...overrides
    };
  }

  static createAdmin(overrides = {}) {
    return this.create({
      role: 'admin',
      ...overrides
    });
  }

  static createMany(count, overrides = {}) {
    return Array.from({ length: count }, (_, i) =>
      this.create({
        email: `test-${i}-${Date.now()}@test.com`,
        ...overrides
      })
    );
  }
}

// Use in tests
it('should list all users for admin', async () => {
  const admin = UserFactory.createAdmin();
  const users = UserFactory.createMany(10);

  await db.insert(admin).into('users');
  await db.insert(users).into('users');

  const response = await api.get('/admin/users', { authUser: admin });
  expect(response.data.users.length).toBe(11); // 10 users + 1 admin
});
```

---

## Test Data Anti-Patterns

### Anti-Pattern 1: Shared Test Data

**Problem:**

```javascript
// tests/user-tests.js
const TEST_USER_ID = 123; // Shared across all tests

it('should update user', async () => {
  await api.put(`/users/${TEST_USER_ID}`, { name: 'Updated' });
  // Changes TEST_USER_ID for other tests!
});

it('should delete user', async () => {
  await api.delete(`/users/${TEST_USER_ID}`);
  // TEST_USER_ID no longer exists!
});
```

**Fix:** Each test creates its own data

### Anti-Pattern 2: Large Setup Files

**Problem:**

```javascript
// setup.js (10,000 lines of test data)
const testData = {
  users: [ /* 1000 users */ ],
  orders: [ /* 5000 orders */ ],
  products: [ /* 500 products */ ]
};

// Slow to load, hard to maintain
```

**Fix:** Load data only when needed

### Anti-Pattern 3: Production Data in Tests

**Problem:**

```javascript
// Testing with real production data
it('should charge user', async () => {
  await chargeCard('4111-1111-1111-1111', 100); // Real charge!
});
```

**Fix:** Use test mode or mocks

### Anti-Pattern 4: Hard-Coded IDs

**Problem:**

```javascript
it('should get order', async () => {
  const response = await api.get('/orders/12345'); // What if ID doesn't exist?
  expect(response.status).toBe(200);
});
```

**Fix:** Create order, use returned ID

---

## What Senior Engineers Know

**Test data is code.** Apply same standards: DRY, maintainability, clarity.

**Realistic data finds real bugs.** "test@test.com" won't catch email validation issues. "user+tag@domain.co.uk" will.

**Cleanup is not optional.** Leftover test data causes flaky tests, pollutes databases, confuses debugging.

**Production data requires sanitization.** Never use real PII, credit cards, SSNs in tests. Legal and ethical issues.

**Test data should be fast to generate.** If setup takes minutes, tests become slow. Use mocks, in-memory databases, or pre-seeded snapshots.

---

## Exercise

**Design Test Data Strategy:**

You're testing an e-commerce checkout flow that requires:
- User account (email, name, address, payment method)
- Product catalog (name, price, stock)
- Shopping cart (items, quantities)
- Payment processing
- Order confirmation

**Your Task:**

1. **Design test data strategy:**
   - Which data is static vs dynamic?
   - How to handle test data isolation?
   - How to clean up after tests?

2. **Create data builders** for User, Product, and Order

3. **Write test** for complete checkout flow with your test data approach

4. **Handle edge cases:**
   - Out of stock product
   - Invalid payment method
   - International address

**Deliverable:** Test code with comprehensive test data management.

---

## Next Steps

- Practice [Automation Strategy](../03-test-automation/01-automation-strategy.md)
- Master [API Testing](02-api-testing.md) with realistic data
- Learn [Database Testing](03-database-testing.md) for data integrity
- Study [CI/CD Integration](../03-test-automation/08-cicd-integration.md) for test data in pipelines
